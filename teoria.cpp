// что бы использовать кириллицу при выводе
#include <clocale>
setlocale(LC_CTYPE, "rus"); // ставим привыше всего остального в main'e  
// что бы работать с кириллицей(ТОЛЬКО НА ВИНДОВС)
#include<Windows.h>
SetConsolePC(1251);
SetConsoleOutputCP(1251);

// Урок 

#include <iostream> // библиотека для cin cout

using namespace std; // это надо писать в начале что бы не писать каждый раз std:: ...
cout << "";          // функция что бы вывести текст в командную строку
\n;                  // новая строка

cin >> num; // получаем число в переменную num

// Действи я с переменными

// типы переменных такие же как и в С
float = 3.14;        // не надо ставить f после цифр
bool isAway = true; // вводим переменную isAway которая может быть только true или false
endl                 // означает конец линии, удобно при выводе результата
+                   // плюс
-                   // минус
*                   // умножить
/                   // поделить
%                   // деление с остачей, выведет только остачу например: 10 % 3 = 1
==                  // сравнивает равны ли друг другу переменные или чтото но главное СРАВНИВАЕТ РАВНО ЛИ...
!=                  // не равно
x *= 2              // умножаем переменную х в два раза
x -= 2              // отнимаем два
x += 2              // увеличиваем на два
x /= 2              // делим на два
х--                 // уменьшает на один
х++                 // увеличивает на один
\n // переход на новую строку  
\t // переход к следующей позиции табуляции
\b // удаление последнего выведеного символа 
\\ // вывести обратный слеш (\) 
const int x = число; // создает константу которую потом нельзя поменять

// Условия

if (условие){       // если
    инструкция что делать если соблюдено условие
}

if (oprt == '/' || oprt == '\\') // если хочу использовать в качестве оператора обратный слеш \ то надо его ставить два раза как на примере!!!

else if (условие){           // иначе если
    инструкция
}

else{                            // иначе
    инструкция
}

false = 0;
true = 1; 
// https://youtu.be/uv6UKqAG820?t=729 обьяснение к тому что ниже
&&         // обьединение условий
||         // или (в условиях)
?          // проверяет равно ли чтото true или false
:          // иначе

switch (x){
// если переменная х
    case '1' : код // равна 1 то будет выполнен этот код
    default : ()   // если никакой изз вариантов не будет выполнен то тогд будет выполнен код в дефолте
}

// Рандом

rand()                  // генератор числ от 0 до 32000
rand() %80              // генератор чисел от 0 до 79
1+rand() % 80           // от 1 до 80

#include <string>       // для использования команды string
string x;               // пеменнная х котороая являеться строкой символов
getline(cin, x)         // получаем строку которую записываем в стринг переменной х
name.length()           // получает длинну строки  пременной name

// Циклы

for (инициализация; состояние; увеличение / уменьшение){
    код
}

while (условие){
    код
}

do{
    код
} while (условие);

break;    // останавливает цикл и выходит с него
continue; // остаеться в цикле но пропускает код который ниже

// Массив и размеры

// название массива это указатель на его первый элемент
// Массивы создаются так же само как и переменные
int arr[3] = {3, 7, 25}; // создали массив arr в котором 3 свободные ячейки и  заполняем их числами 3,7,25
// если мы сразу прописали элементы массива то размер массива (тоесть [3]) можно не писать
// счет начинаеться с 0
int arr_2[][] = {{23, 4}, // Двухмерный массив(Матрица)
                 {7, 6},
                 {9, 3}}; 
что бы массив создаля без мусора внутри а с нулями то надо после обьявления массива поставить {} например:
int arr[2][4]{}; // все внутри двухмерного массива будет нулями а не мусором
int arr_1[]{}; // все внутри массива будет нулями а не мусором

sizeof(переменная) // команда которая возвращает размер переменной в байтах 
что бы получить размер массива надо поделить размер в байтах на его тип данных. Например: 
int arr[]={32,423,543,12,4,5};
sizeof(arr)/sizeof(int); // получили количество чисел в массиве arr если бы был не int a float то в формуле надо записать float
sizeof(arr)/sizeof(arr[0]) // то же само что и сверху но так не важно какой тип массива, формула будет работать с любой


// Поинтеры(Указатель)

// указатель это переменная которая хранит в себе адрес на другую переменную
int x = 6;
int *ptrx = &x; 
// передает адресс переменной х в поинтер х, тоесть ptrx носит в себе адрес на переменную х
// указатель должен быть такого же типа даннных как и переменная
cout << ptrx;
// тут получиться так что мы выведем адресс переменной х
cout << *ptrx;
// тут же му уже разыменуем указатель и получим значение(А НЕ АДРЕС) переменной х
*ptrx = 67;
// меняем значение переменной х
**ptr_ptrx = *&ptrx;
// когда мы создаем поинтер на поинтер то должны ставить две звездочки
int *pArr = название массива;
// осздаем указатель на массив
int (*pf)(int) = &myFunction; 
// указатель на функцию
int result = (*pf)(5); 
// вызов функции через указатель с передачей параметра 5

// Ссылки

int &nameRef = name;
// так выглядит создание ссылки на переменную

// Динамическая память

// https://www.youtube.com/watch?v=l75xG4930bc&t=322s
// команда new  выделяет динамическую память под что-то
int *ptrNum = new int(7); 
// Выделяем переменной ptrNum память с помощью new int(тут мы дали значение переменной)
// обязательно сначала писать звездочку а потом название переменной 
int *ptrNum = new int;
*ptrNum = 7;
// это равносильно тому что выше , мы можем либо сразу назначить чилос переменной либо потом но надо это делать с помощью звездочки(!!!)
delete ptrNum; // Удаляет выделеную память для переменной ptrNum что бы она не грузила компьютер

// Динамический массив

float *ptrarr = new float [10]; 
// Выделяем динамическую память для массива, там где 10 это кол-тво элементов массива
delete [] ptrarr;
//овобождаем память от динамического массива
for (int i=0; i<10; i++){
    ptrarr[i]= rand()%80+1; // для работы с массивом с выделеной динамической памятью не надо ставить звездочку в начале(!!!)
}
// Заполнения массива рандомными числами


// Двухмерный динамический массив   https://www.youtube.com/watch?v=UhiG8c7hmIA

int **arr = new int[rows];
// создали основной массив указателей на другие массивы
for (int i =0; i < rows; i++){
    arr[i] = new int [cols]; 
}
// выделяем динамическую память под вутрение массивы на которые булут указывать указатели основного массива

// Константные аргументы функции. Константный указатель. Константные параметры.

int name_fun(int const size, int * const arr)
// передаем в параметрах константу что бы в функцие его нельзя было поменять
int * const arr
// передаем как константу только адрес массива, но с массивом мы работать можем
const int * const arr
// передаем как константу адрес и сам массив, тоесть с элементами массива мы рабоать не сможем

// Строки

char symbol = '';
// хранит в себе какой-то символ и только один
strlen(string); 
// возвращает размер строки

// Преобразование типов

cout << (int)a << endl; 
// выводим число типа int в консоль
cout << (bool)a << endl; 
// выводим значение типа boolean
cout << (bool)(a>30) << endl;
// выведет 0(false) если а меньше 30 и выведет 1(true) если больше

// Указатели символьные строки и функции. Строки и указатели

char *string = "Hello!";
cout << string << endl;
// выведет Hello

// Конкатенация строк что это. Объединение строк.Тип данных string

#include<cstring>
// заголловочный файл для работы команд связанх с строками но он содержит в себе более старые функции для работы через С
// Конкатенация строк это обьединение двух строк
strcat(первая строка в которую все запишется , вторая строка которая будет принята как константа)
// Конкатенация двух строк в стиле яызка си, таким образом первая строка будет изменена и будет уже 1+2 строками
#include<string>
// более новый заголовочный файл для работы команд связаных с строками(который содержит в себе и то что было в языке С)
string str1 = "fsdfd";
// создали строку только более нового типа(в стиле С++)
str1 + str2
// Конкатенация строк

// Указатель на функцию в качестве параметра. Передача функции в качестве параметра

// https://www.youtube.com/watch?v=_6eG9Q40lFM&list=PLQOaTSbfxUtCrKs0nicOg2npJQYSPGO9r&index=79
// тип функции (*имя указателя)(спецификация пареметров)
// спецификация параметров - спиксок параметров функции
int main(){
    void (*fooPointer1)();
    // создали указатель на функцию с названием fooPointer1
    fooPointer1 = fun1;
    // передали указателю fooPointer1 фукнцию fun1
    fooPointer1();
    // вызываем функцию fun1 через указатель fooPointer1
}
int main(){
    int (*funPoint)(int a);
    // создаем указательна функцию который принимает один параметр и функция с возвращаемым типом 
    funPoint = fun4;
    // назначаем указателю функцию
    cout << funPoint(43) << endl;
    // передаем указателю параметр котрый передает его функции и выводим то что вернет та функция
}

// Макрос. Условная компиляция

#define FOO(x,y) ((x)*(y))
// при вызове FOO(5,6) мы получим результат умножения 5 на 6 тоетсь 30

#ifdef
// директива используется для проверки, определен ли макрос
#endif
// конец проверки
#ifndef
// директива используется для проверки, не определен ли макрос
#else
// директива используется вместе с #ifdef или #ifndef для указания альтернативного кода, который будет использован, если макрос не определен
#if
// директива используется для проверки условия во время компиляции

// Условный тернарный оператор что это. Как работает. Как использовать

условие ? выражение1 : выражение2

int max = (a > b) ? a : b;
// Здесь, если a больше, чем b, то значение max будет равно a, в противном случае - b

// Структура

// стурктуры создаються отдельно, вне main 
struct more{
    int weight;
};

struct weh { // создание структуры weh это название структуры
    int wheels; // вводим сюда переменные которые будут как бы описывать то с чем мы работаем
    float speed;
    more.mor; // подлючаем сюда вторую структуру с названием mor
};
// что бы испльзовать структуру уже в мэйне надо написать 
weh gnu; // применяем структуру к этому обьекту (gnu(назвать его мы можем как хотим))
// что бы заполнить структуру для этого обьекта делаем следующее 
gnu.wheels; // заполняем переменную wheels обьявленую в структуре
gnu.speed; // заполняем переменную speed  обьявленную в структуре
// так же есть альтернатива что бы писать быстрее 
weh gnu = {4,456}; // заполняем согласно порядку в нашей структуре,т.е. в структуре первое wheel и значит первое что будет в скобках будет назначаено whhel

cout << weh.speed; // выведет скорость этого элемента 
gnu.more.mor = 133 //обращаемся к переменной котоая лежит в структуре другой структуры
// название обьекта к которому применена структура . название переменной основной структуры . потом той которую мы подключили

// Enum и switch

Enum - это перечисление, позволяющее присвоить имена набору целочисленных значений.
enum имя_перечисления {
    значение_1,
    значение_2,
    ...
    значение_N;
};
switch (floor){ //если пременная floor
    case значение_1: // будет равна значчению 1 которое мы назначили в enum
        ...         // выполниться код 
        break;
}

// Работа с файлами

#include <fstream> // позволяет работать с файлами
ofstream  название_обьекта; // для записи в файл 
ifstream название_обьекта; //для чтения из файлов 

file.open("название_файла"); // открывает файл, если такого нет то он будет создан
file << ""; // запишет в файл какойто текст 
file.close(); // после работы с файлом следует его закрыть 

для оптимизации кода так же можно написать код который выше следующим образом:
ofstream название_обьекта ("название_файла");
// тут уже раюотаем с файлом который открыли
char text[50];
название_обьекта.getline(text, 50); // получаем строку на 50 символов из какого то файла и записываем ее в переменную text

есть много вариантов работать с файлами и их можно найти в интернете 
вот пример одного и как использовать 
ofstream file ("text.txt", ios_base::app);
    file << "Work with files in C++";
    file.close();

ios_base::app // добавляет чтото в конец файла
в этом коде мы дописываем в конец файла еще раз эту надпись 

// Функции

возвращаемое_значание_функции навание_функции(параментры которые функция получит при начале, иными словами то что мы уже хотим передать функции){
    код функции;
}
// если функция находиться под мейном то ее заголовк надо обьявить в самом начале тоесть ее тип(void,float) так же название и параметры
параметр по умолчанию это когд амы в новой функции в ее параметры указываем чтото в ее переменные т.е.
int fun(int a = 5)
это будет параметр а по умолчанию будет равен 5 и если мы при вызове этой функции ничего не передадим в параметры то будет использовано значение 5

inline int fun(){}
// inline это - встраиваемая функция которая используеться для того что бы программа не искала нашу функцию по всей памяти(в основном подходит для маленьких функций)
// https://www.youtube.com/watch?v=onKnrNJZRbs

// Перегрузка функции

перегрузка функции это когда мы создали функцию, а потом создаем функцию с таким же названием и типом,
но назначаем ей другой код и параметры которые она принимает. И по количеству параметров компилятор понимает
где какая функция
или же она будет ориентироваться по типу переменных в параметрах

// Шаблонны функции

// Шаблонная функция в C++ - это функция, которая может принимать аргументы различных типов, определенных пользователем, а не только один тип данных.
template <typename T>
T fun(T a, T b){
    return a+b;
}
// template <typename T> - создает шаблон функции с видом переменных T (так же вместо typename можно использовать class между ними нет разницы но class лучше использовать с классами)
// T fun() - Т означает что тип возвращаемых данных будет такой же как и эта переменная (строка,символ, число целое или не целое число)
// fun(T a, T b) - на месте обычного int и тд мы пишем то что указали в typename и он сам определит какой это тип данных а после Т пишем название переменной
// что бы использовать два разных типа данных нао добавить еще один typename 
template <typename T1, typename T2>
T1 fun(T1 a, T2 b){
    return a+b;
}
// данный код будет принимать два разных типа данных и будет возвращать тот тип данных которым являеться Т1(т.е. если Т1 будет чилом то функция вернет число, если строкой то строку )

// Cтек

// Стек - это облать памяти в которой выполняеться наша программа
// Стек (stack) в C++ является одним из типов контейнеров, предоставляемых стандартной библиотекой языка. 
// Стек - это коллекция объектов, которая работает по принципу "последним вошел, первым вышел" (LIFO).
// То есть, элемент, добавленный последним, будет удален первым. 

// Рекурсия

// Рекурсия это вызов функции самой себя
// https://www.youtube.com/watch?v=_WGNSVDb0t8&t=15s (все про рекурсию)

// Локальная и глобальная переменные

Локальная переменная это та которая находиться внутри какойто функции 
глобальная переменная прописывается вне функции и ее будут вдеть все функции

если есть локальная и глобальная переменные с одинаковым названием, что бы получить доступ к глобальной надо поставить
двоеточие (::str - получем доступ к глобальной переменной)

//Математичекие операции

# include <cmath>

pow(то что мы хотим вознести, степень) // возводит в степень
abs(число) // модуль числа
sin (число в радианах) // синус числа
cos (числов в радианах) // косинус числа
sqrt (не отрицательное число) // корень числа
ceil(число с точкой) // округляет число в большую сторону
floor(число с точкой) // округляет число в меньшую сторону
exp (число) // выводит число по экспоненте 
log (число) // логорифм от числа

ООП 
// Что такое класс. Что такое объект класса. Экземпляр класса это. Класс ООП

class Human{
// тело класса
int age;
};
// создали классс названием Human
int main(){
    Human Maksym;
}
// создали обьект класса Human
Maksym.age = 18;
// Говорим что переменная age для обьекта Maksym = 18

// Методы класса. Что такое методы в программировании. Вызов метода класса

class Human{
    int x = 0;
    void Print(/* В параметр ничего не передаем потому что функция находиться в одном классе с переменными и видит их */){
        cout << x << endl;
    }
};

int main(){
    Human person;
    // Создали обьект с классом Human
    person.Print();
    // вызвали функцию что бы вывести чтото из класса Human назначеное для обьекта person
}

// Модификаторы доступа классов public private protected. Спецификаторы доступа
class Human{
public:
// следующие функции-члены и переменные доступны извне класса
private:
// доступ к следующим функциям-членам и переменным возможен только из других функций-членов того же класса
// в основном переменные кладут в этот доступ
protected:
// к следующим функциям-членам и переменным могут обращаться другие функции-члены того же класса, а также любые производные классы.
};

// Что такое геттеры и сеттеры для класса. Методы get и set. Инкапсуляция это

Геттеры и сеттеры - это методы класса, которые обеспечивают доступ к приватным полям объекта через публичный интерфейс класса.
Метод get возвращает значение приватного поля, а метод set устанавливает новое значение для приватного поля. 
Геттеры и сеттеры позволяют контролировать доступ к приватным полям и обеспечивают возможность проверки и валидации данных перед их установкой или получением.

int getAge() const {
    return age;
}
// Геттер
// Геттеры принято назвать так что бы в начале было слово Get

void setName(const string& newName) {
    name = newName;
}
// Сеттер
// Сеттеры принято назвать так что бы в начале было слово Set

// Конструктор класса

class some{
    public:
    some()// запись some{} является конструктором
    // конструктор пишеться в доступе public
    {
        // все что булет записано в конструктор(сюда), будет выполняться автоматически пир создании обьекта
    }
};

some(int a, int b){
}
// если мы задали параметры конструктора то при создании обьекта их надо указать
some a(34,56)
// указали параметры конструктору обьекта a класса some

// Перегрузка конструкторов класса. Что такое перегрузка. Как перегрузить конструктор

// https://www.youtube.com/watch?v=sLQLUed6izY&list=PLQOaTSbfxUtCrKs0nicOg2npJQYSPGO9r&index=93
// работает также само как и перегрузка функции, кол-ство перегрузок неограничено

// Деструктор что это. Зачем нужен деструктор класса в ООП

class MyClass{
    public:
    ~MyClass{}
    // создали деструктор 
};
// Деструктор в классе должен быть один и для него нет возможности перегрузки и для него нет перегрузки

// THIS

this -> 
// В C++ ключевое слово  this используется для обращения к объекту класса, в котором он был вызван
class Person {
private:
    int age;
public:
    void setAge(int age) {
        this->age = age;
    }
};
// В этом примере this указывает на текущий объект, а -> используется для доступа к переменной age (которая находиться в private)
// и установке ее значения (которое мы получили в функции setAge)

// Конструктор копирования. Что это. Пример. Когда вызывается Копирование объектов по умолчанию
// https://www.youtube.com/watch?v=3x9nd6Tm7Pc&list=PLQOaTSbfxUtCrKs0nicOg2npJQYSPGO9r&index=96

int main(){
    MyClass a(32);
    MyClass b(a);
}
// MyClass b(a) создается таким же как и MyClass a(32), полностью его копируя

class MyClass{
private:
    int size;
public:
    int *data;
    /// Создание и заполнение массива
    MyClass(int size){
        this -> size = size;
// Мы создаем новую вещь и хотим, чтобы она имела размер, поэтому мы устанавливаем размер новой вещи таким, каким мы ее задаем
        /// Заполняем новый массив
        this -> data = new int [size];
        for (int i = 0; i<size; i++)
            data[i] = i;
        cout << "Вызвался конструктор\t" << this << endl;
    }
    
    
    /// Конструктор копирования
    MyClass(const MyClass &other){
        cout << "Вызвался конструктор копирования\t" << this << endl;
        this -> size = other.size;
// Мы хотим, чтобы новая вещь имела тот же размер, что и копируемая вещь, поэтому мы устанавливаем ее размер таким же, как размер копируемой вещи
        this -> data = new int[other.size];
        for(int i = 0; i < other.size; i++)
            this -> data[i] = other.data[i];
    }
};
delete []this -> data;
// удалим данные которые в указателе this

MyClass A(10); 
// Создали обьект А
MyClass B(a); 
// вызвали конструктор копирования что бы обьект В при создании был такой же как и А
MyClass B = A;
// аналогичная запись, тут тоже ,если В нигде небыл обьявлен ранее, то вызовется конструктор копирования

// Перегрузка операторов пример. ООП. Перегрузка оператора присваивания
// https://www.youtube.com/watch?v=nMM98LVJn-U&list=PLQOaTSbfxUtCrKs0nicOg2npJQYSPGO9r&index=96

class MyClass {
public:
    MyClass& operator=(const MyClass& other) {
        // при выолнении a = b мы попадаем сюда и код который тут будет выполнен
        return *this;
    }
};

MyClass a;
MyClass b;
a = b; 

// Перегрузка оператора сложения

point operator +(const point & other){
    point temp;
    temp.x = this -> x + other.x;
    temp.y = this -> y + other.y;
    return temp;
}

// Перегрузка инкремента и декремента. Постфиксного и префиксного

// префиксный инкримент(++a)
point & operator ++(){
    this -> x += 1;
    this -> y++;
    return *this;
    }    
// постфиксный инкримент(a++)
point & operator ++(int value){
    this -> x++;
    this -> y++;
    return *this;
}

// Перегрузка оператора индексирования

int & operator[](int index){
return arr[index];
}

// Дружественные функции и классы

// создаем дружественную функцию
class ClassA {
private:
    int private_data_;

    friend void functionC(ClassA& obj); 
    // объявляем функцию как дружественную
};
void functionC(ClassA& obj) {
    obj.private_data_ = 42;
    // функция имеет доступ к приватным членам ClassA
}

// Определение методов вне класса. Вынести функцию в из класса. Вынести описание метода вне класса

class MyClass{
public:
    void PrintMessage();
    // обьявляем что есть такая функция
    
};

void MyClass::PrintMessage() 
//создаем функцию вынесеную из класса (возвращаемый тип, название класса, название функции)
{
    cout << "Hello!" << endl;
}

// Дружественный метод класса

class ClassB{
    void fun_1(ClassA &some){
        cout << some.private_data << endl;
    }
};

class ClassA{
private:
    int private_data_;

    friend void ClassB::fun_1(ClassA &some);
};

// Дружественный класс

class ClassA {
private:
    int private_data_;

    friend class ClassB; 
    // объявляем ClassB как дружественный класс
};

class ClassB {
public:
    void function(ClassA& obj) {
        obj.private_data_ = 42; 
        // ClassB имеет доступ к приватным членам ClassA
    }
};

// Ключевое слово static

class MyClass {
public:
    static int counter; 
    // объявление статического поля класса
};

int MyClass::counter = 0; 
// инициализация статического поля класса

int main() {
    MyClass obj1, obj2, obj3;
    MyClass::counter++;
    // использование статического поля класса
    cout << "Number of objects created: " << MyClass::counter << endl;
    return 0;
}

// Статические методы класса
// https://www.youtube.com/watch?v=aNilqhdlDXQ

// Статические методы класса в C++ - это методы, которые принадлежат самому классу, а не его объектам. 
// Такие методы могут вызываться непосредственно через имя класса, без создания объекта.

class MyClass {
public:
    static void myStaticMethod() {
        // Код статического метода
    }
};

MyClass::myStaticMethod();
// Вызов статического метода класса

// Вложенные классы с++
// https://www.youtube.com/watch?v=wPzP8G6OLJM

class MyClass {
public:
    int x;
};

int main() {
    MyClass myArray[5];
    // статический массив объектов класса MyClass
    return 0;
}

class MyClass {
public:
    int x;
};

int main() {
    MyClass* myArray = new MyClass[5];
    // создать динамический массив объектов класса MyClass
    delete [] myArray;
    return 0;
}

// Что такое агрегация и композиция. Отношения между классами и объектами
// https://www.youtube.com/watch?v=N7DzmfLBolM

// Наследование в ООП

class MyClass{
public:
    int some = 10;
};

class Derived : public MyClass {};
// создаем свой класс : модификатор доступа название класса с которого наследуем

// Модификаторы доступа при наследовании

// private – члены базового класса не будут доступны в наследственном классе.      
// protected – члены базового классa будут доступны в наследственном классе, но не будут доступны за пределами наследственного класса.
// public – члены базового класса, объявленные как public, будут доступны как в наследственном классе, так и за его пределами.

class Base {
private:
    int x;

protected:
    int y;

public:
    int z;
};

class Derived : public Base {
public:
    void foo() {
        x = 10; 
        // ошибка: x является закрытым членом Base
        y = 20; 
        // можно: y является защищенным членом Base
        z = 30; 
        // можно: z является открытым членом Base
    }
};

int main() {
    Derived obj;
    obj.x = 10; 
    // ошибка: x является закрытым членом Base
    obj.y = 20; 
    // ошибка: y является защищенным членом Base
    obj.z = 30; 
    // можно: z является открытым членом Base
    return 0;
}

// Вызов конструктора базового класса из конструктора класса-наследника

class BaseClass {
public:
    BaseClass(int value) {
        // код конструктора базового класса
    }
};

class DerivedClass : public BaseClass {
    // вызов базового конструктора из родительского класса
public:
    DerivedClass(int value) : BaseClass(value) {
        // код конструктора класса-наследника
    }
};

// Виртуальные методы класса
// https://www.youtube.com/watch?v=YlbFPAugFNAасса

// Абстрактный класс

// Абстрактный класс фигуры
class Shape {
    public:
        virtual float getArea() = 0;
        // Чисто виртуальная функция для вычисления площади фигуры
};
// Производный класс Круг
class Circle : public Shape {
    // Наследование от абстрактного класса 
private:
    float radius;
public:
    Circle(float r) {
        radius = r;
    }

    float getArea() override {
        // переписыываем виртуальную функцию из абстрактного класса
        return 3.14 * radius * radius;
    }
};

// Виртуальный деструктор

class Base {
public:
    virtual ~Base() {
        // виртуальный деструктор
    }
};

class Derived : public Base {
public:
    ~Derived() override {
        // деструктор класса-наследника
    }
};

int main() {
    Base* b = new Derived();
    // обьект основгого класса b - адрес на обьект класса наследника
    delete b;
    return 0;
}
// данный код нужен для того что бы удалить потом всю выделеную динамическую помаять если мы вызывали обьект класса наследника через обьект-поинтер основного класса
// так мы предотвращаем утечку памяти 

// Делегирующие конструкторы 

class Human {
public:   
    Human(string name){
        this -> Name = name;
        this -> Age = 0;
        this -> Weight = 0;
    }
    Human(string name, int age): Human(name){
        // присваивание переменной Name делегируеться из конструктора выше 
        this -> Age = age;
        this -> Weight = 0;
    }
}

// Bызов виртуального метода базового класса

class Base {
public:
    virtual void foo() {
        cout << "Base::foo()\n";
    }
};

class Derived : public Base {
public:
    void foo() override {
        cout << "Derived::foo()\n";
    }

    void bar() {
        Base::foo(); // вызов метода родительского класса
        foo(); // вызов метода данного класса
    }
};

int main() {
    Derived d;
    d.bar();
    return 0;
}

// Множественное наследование

class Car {
public:
    void Drive(){
        cout << "I drive car!" << endl;
    }
};
// создали первый класс

class Airplain{
public:
    void Fly(){
        cout << "I fly!" << endl;
    }
};
// создали второй класс

class FlyCar: public Car, public Airplain{
    
};
// создали третий класс который наследует все публичное от классов Car и Airplain

// Множественное наследование одинаковые методы. Преобразование

FlyCar c;
// Создаем обьект С класса FlyCar
((Car)c).Use();
// преобразовываем С в обьект класса Car и вызываем метод который указан в классе Car
((Airplain)c).Use();
// преобразовываем С в обьект класса Airplain и вызываем метод который указан в классе Airplain
// Но есть разные варианты как это сделать
(Car(c)).Use();
// будет рабоать так же само как и ((Car)c).Use();
(Airplain(c)).Use();
// аналогично ((Airplain)c).Use();

// Интерфейс

// Интерфейс в C++ - это абстрактный класс, содержащий только чисто виртуальные функции (pure virtual functions), 
// которые не имеют реализации в базовом классе. Интерфейс используется для определения общего набора методов,
// которые должны быть реализованы в классах-наследниках.

class Shape {
public:
    virtual void draw() const = 0;
    virtual double area() const = 0;
};
// делаем абстрактный класс который являеться интерфейсом

class Circle : public Shape {
public:
    Circle(double r) : radius(r) {}
    void draw() const override { /* реализация */ }
    // переписывает функцию полученую из абстрактного класса путем наследования
    double area() const override { /* реализация */ }
    // переписывает функцию полученую из абстрактного класса путем наследования
private:
    double radius;
};
// делаем класс который наследует абстрактный класс(Интерфейс) Shape и реализируем его 
void printArea(const Shape& shape) {
    cout << "Area is " << shape.area() << endl;
}
// функция которая будет выводить результат
int main() {
    Circle c(5);
    printArea(c); 
    // вызов функции с объектом типа Circle, реализующим интерфейс Shape
    return 0;
}

// Виртуальное наследование. Ромбовидное наследование

class A {
public:
  int x;
};
// создаем абстрактный класс

class B : virtual public A {
    // делаем класс А виртуальным
public:
  // ...
};

class C : virtual public A {
    // тут тоже 
public:
  // ...
};

class D : public B, public C {
    // благодаря тому что сделали класс А виртуальным, так как он есть родительским классом для классов С и В,
    // то класс А вызоветься один раз и не будет конфликта данных, при попытке получения переменной х
public:
};

// try catch 

try {
    // код в котором может быть ошибка 
} catch (const exception &ex/* тип исключения, которое мы хотим перехватить и обработать */) {
    // Код который будет выполняться при ошибке  
}
const exception &ex
// класс exception который представляет собой класс стандартных ошибок 
runtime_error
// Представляет ошибку, возникающую во время выполнения программы
out_of_range
// Исключение, которое возникает при обращении к элементу контейнера (например, массива, вектора или строки) по индексу или итератору, выходящему за пределы допустимого диапазона.
logic_error
// Представляет ошибку в логике программы
ex.what()
// Возвращает описание ошибки 
ex.code()
// Возвращает код ошибки
ds.exceptions(ifstream::badbit | ifstream::failbit);
// Используеться при работе с файлами для корректной работы блока try catch 
// badbit указывает на серьезные ошибки, связанные с самим потоком, такие как невозможность открытия файла или ошибки ввода-вывода.
// failbit указывает на ошибки формата или состояния потока, например, некорректный формат данных.

// Throw

throw тип ошибки
// Оператор который бросает тип ошибки и в чем она заключается 
// типо ошибки может быть что угодно: строка, символ, число и тд и тп
throw runtime_error("Чисило меньше нуля");
// выводим в качестве ошибки строку
catch(const exception &ex)
// то что находиться внутри catch должно соотвествовать по типу данных с типом ошибки (throw) 
// лучше всего спользовать exception и так мы через ex.what() можем получить throw и понять в чем ошибка

// Несколько блоков catch

try {
    // Код, в котором может возникнуть исключение
    throw SomeException(); // Генерация исключения
}
catch (const SomeException& ex) {
    // Обработка исключения типа SomeException
    // ex содержит информацию об исключении
}
catch (const AnotherException& ex) {
    // Обработка исключения типа AnotherException
}
catch (...) {
    // Обработка всех остальных исключений
}

// Свой класс exception(исключений)
// https://www.youtube.com/watch?v=wCUl7yTHWq8

// Перечисляемый тип enum
// https://www.youtube.com/watch?v=BMmbQ81lQd0

enum Color {
    RED, // 0
    GREEN, // 1
    BLUE // 2
};

int main() {
    Color col = RED;
    cout << col << endl; 
    // выведет 0, так как RED = 0
}

// Пространства имен. namespace

namespace MyNamespace {
    int x = 5;
    
    void printX() {
        cout << "x = " << x << std::endl;
    }
}

int main() {
    MyNamespace::printX();  
    // Выводит "x = 5"
    
    return 0;
}

using namespace MyNamespace;

int main() {
    printX();  
    // Берет данные из пространства имен MyNamespace и выводит "x = 5"
    
    return 0;
}

// Шаблоны классов

template <typename T>
class MyClass {
private:
    T value;

public:
    MyClass(T val) {
        value = val;
    }

    T getValue() {
        return value;
    }

    void setValue(T val) {
        value = val;
    }
};

MyClass<int> obj1(5);        
// Создание экземпляра MyClass с типом int
int value1 = obj1.getValue();

MyClass<double> obj2(3.14); 
// Создание экземпляра MyClass с типом double
double value2 = obj2.getValue();

MyClass<string> obj3("Hello");  
// Создание экземпляра MyClass с типом std::string
string value3 = obj3.getValue();

// Структуры

struct BaseStruct {
    int x;
    // Изначально создает пременную в стиле public (обычно когда в классе создают переменную без модификатора то он становиться автоматически private)
};

struct DerivedStruct : BaseStruct {
    // DerivedStruct наследует член x от BaseStruct как public
};

class BaseClass {
    int private;
public:
    int public;
};

class DerivedClass : BaseClass {
    // DerivedClass НЕ наследует private от BaseClass
    // DerivedClass наследует public от BaseClass
};

struct BaseStruct {
    int public;
};

struct DerivedStruct : public BaseStruct {
    // DerivedStruct наследует public от BaseStruct с публичным доступом
};

// Использование структур

struct Point {
    int x;
    int y;
};
// Создали структуру

void printPoint(Point p) {
    cout << "Point coordinates: (" << p.x << ", " << p.y << ")" << endl;
}
// Выводим значения из структуры

int main() {
    Point myPoint = { 3, 5 };
    printPoint(myPoint);
    return 0;
}
// Вывод: Point coordinates: (3, 5)

// Умные указатели

template<typename T>
class SmartPointer{
private:
    T *ptr;
public:
    SmartPointer(T *ptr): ptr(ptr){
        
    }
    
    ~SmartPointer(){
        delete ptr;
    }
    
    T& operator *(){
        return *ptr;
    }
};
// Создали шаблонный класс SmartPointer который будет умным указателем и будет рабоать с любым типом
SmartPointer<int> Pointer = new int(5);
// Создали умный указатель типа int и назначили ему динамичесскую память с числом 5

// auto_ptr | unique_ptr | shared_ptr | Умные указатели
// https://www.youtube.com/watch?v=dpRozfXepnA&list=PLQOaTSbfxUtCrKs0nicOg2npJQYSPGO9r&index=153

#include <memory>
// библиотека для того что бы подключить умные поинтеры
unique_ptr
// unique_ptr обеспечивает уникальное владение объектом. Это означает, что у unique_ptr есть единственный владелец объекта
unique_ptr<int> ptr(new int(5));    
// Использование ptr
cout << *ptr << endl;
// После выхода из области видимости ptr автоматически освобождает память

shared_ptr

// shared_ptr предоставляет разделенное (shared) владение объектом.
// Это означает, что у shared_ptr может быть несколько владельцев, и объект будет удален только тогда, 
// когда все владельцы shared_ptr освободят его или явно освободят память
shared_ptr<int> ptr1(new int(5));
shared_ptr<int> ptr2 = ptr1;
// Создание второго shared_ptr, разделяющего владение с ptr1
cout << *ptr1 << endl;
cout << *ptr2 << endl;
// Использование ptr1 и ptr2
// После выхода из области видимости ptr1 и ptr2 автоматически освобождают память
    
//










































// climits

#include<climits>
// файл содержит константы связаные с лимитами типов данных
CHAR_BIT
// количество бит в байте
CHAR_MIN
// минимальное значение для типа char
CHAR_MAX:
// максимальное значение для типа char
INT_MIN 
// минимальное значение для типа int
INT_MAX 
// максимальное значение для типа int
LONG_MIN
//  минимальное значение для типа long
LONG_MAX
//  максимальное значение для типа long

// Работа с файлами

#include<fstream>
// библиотека для работы с файлами
// библиотека для работы с файлами являеться набором классов и потому с этим всем мы работаем как с классами

// Запись в файл

ofstream название;
// создали обьект который будет файлом
название.open("файл.txt");
// открываем файл с таким названием, если такого файла нет то он создастся а если есть то перезапишется 
название << "Hello World!";
// Записываем в файл строку Hello World!
название.open("файл.txt",ofstream::app);
// При повторной попытке создать или открыть файл он не будет удаляться и заново перезаписываться
название.is_open()
// возвращает true если файл открыт и false если файл не открыт
название << a;
// Запись в файл переменной А
название.close();
// закрывает файл после использования. Лучше пользоваться этим как с динамической памятью

// Чтение с файла

ifstream название (путь к файоу)
// создали обьект для чтения данных с файла
название.open(путь к файлу);
// открываем файл по указаному пути и названию
название обьекта >> название переменной
// запишем данные из обьекта в переменную. Данные состоят из символов вплоть до первого пробела
getline(название обьекта с которого считаем данные, переменная куда записываем считанные данные);
// функция позволяет получить строку, тоесть не до первого пробела а до следующего enter'a
while (название.get(ch)/*Если получилось взять чтото с файла то true, а если нет то false*/)
    cout << ch;
// цикл что бы вывести данные из файла по символу (само будет перескакивать на следующий элемент)
while (название.eof())
// будет работать пока не дойдет до конца файла (eof - End Of File)
название.seekg(0, ios::beg);
// ставит курсор в самое начало файла

// Запись обьекта класса в файл. Чтение объекта из файл

название обьекта записи данных.write((char*) &название обьекта записи данных, sizeof(название класса который записываем))
// записываем данные класса в файл
название обьекта записи данных.read((char*) &название обьекта записи данных, sizeof(название класса который записываем))
// читаем данные класса из файла

// Чтение и запись в файл с++ используя класс fstream
// https://www.youtube.com/watch?v=bTysglLJ8No

fstream название(path, fstream::in | fstream::out | fstream::app)
// название обьекта файла и мы сказали ему что он может и записывать и читать файл который мы ему назначли
// так же он не чистит данные того файла при повторном открытии
название >> msg;
// записываем данные полученые от файла в переменную msg

// Перегрузка операторов потокового ввода и вывода

ostream & operator << (ostream & os, const Point &point)
// os- это сылка на определенный поток вывода (cout, или название обьекта файла) дальше идет << и потом Point &point сслыка на обьект типа нашего класса
// другими словами мы перезагружаем такую запись cout(поток вывода os) << po(обьект класса Point)
{
    os << point.x << " " << point.y << " " << point.z << endl;
    // показываем как мы будем выводить данные с обьекта класса point 
    return os;
    // возвращаем все это как определеннный поток
}
// данная функция отвечает за то что бы перегрузить оператор вывода << 

istream & operator >>(istream & is, Point & po){
// istream &is - поток ввода, Point & po - ссылка на обьект класса Point
// то есть мы перезагружаем такую читание cin(поток ввода is) >> po(обьект класса Point)
    is >> po.x >> po.y >> po.z;
    // читаем данные из потока ввода и сохраняем их в обьект класса Point
    return is;
    // возвращаем все это как определеннный поток
}
// данная функция отвечает за то что бы перезагрузить оператора ввода >> и работает так же само как и вывод 








// STL бибилиотеки
// vector   https://www.youtube.com/watch?v=1cKvMZOJeeE&list=PLQOaTSbfxUtDWAtIYme5MLZ1l0GTyUYkB&index=1&t=454s
// вектор это быстрый динамический массив

#include <vector>
// подключаем векторы
vector<int> myVector;
// создали вектор с типом данных int
vector<int> Vector(30,55);
// сразу создает 30 элементов в векторе и все эти элементы будут равны 55 
myVector.push_back(число);
// добавляем число в конец вектора
myVector.size();
// получаем кол-ство элементов в векторе
myVector.at(индекс элемента);
// тоже самое что и myVector[индекс элемента], но плюс использования at в том что он не дает выйти за пределы вектора, но он медленее
myVector.clear();
// очищаем вектор
myVector.pop_back();
// удаляем последний элемент
myVector.capasity();
// возвращает количество элементов в векторе которые мы можем изменять без переписи вектора
myVector.reserve();
// указываем сколько будет элементов которые мы можем изменять без переписи вектора
myVector.shrink_to_fit()
// подгоняет кол-ство свободных элементов к кол-ству занятых элементов (если занято 8, а выделено 100 то после этой функции свободных будет тоже 8)
myVector.insert(индекс элемента, число);
// добавляем число в индекс элемента
myVector.empty();
// возвращает true если вектор пустой
myVector.resize(2,23);
// меняем кол-во элементов в векторе на 2 (и эти два элемента будут равны 23)




































// Прочая полезная фигня

// ООП
Human(string name): Name(name), Age(0), Weight(0){
// this -> Name = name;
// this -> Age = 0;
// this -> Weight = 0;
}
// сокращенная запись
Horse(string name, int age, string breed, int height) : Animal(name, age), breed(breed), height(height) {}
// тут ситуация когда мы хотим взять параметры с класса-родителя

// Проверка на то что ввели число а не чтото другое
if (cin.fail()) 
    // Этот код проверяет, была ли ошибка при считывании значения с помощью cin. Если была ошибка, то функция cin.fail() возвращает true. 
    // Это может произойти, например, если пользователь ввел не число, а символ, и cin не смогла преобразовать его в число. 
{
    cin.clear();
    // Далее, если была ошибка, то вызывается функция cin.clear(), которая очищает флаг ошибки failbit у потока ввода.
    // Это позволяет продолжить считывание значений с cin без ошибок.
    cin.ignore(numeric_limits<streamsize>::max(), '\n');
    // Затем вызывается функция cin.ignore(), которая удаляет все символы из буфера ввода до символа новой строки ('\n'). 
    // Это нужно, чтобы избежать повторного чтения неверного ввода и продолжить работу с правильным вводом.

    // numeric_limits<streamsize>::max() в этой функции используется для указания максимального количества символов для удаления из буфера.
    // streamsize - это тип, используемый для представления размера потока ввода/вывода.
}

// считывать строки которые пользователь вводит лучше командой .getline
char string1[500];
cin.getline(string1, 500);
или
getline(cin, string1);

ВСЕ ФУНКЦИИ СО СТРОКАМИ САЙТ: cppstudio.com/post/437/

// Объявление перечисления в C++ выглядит следующим образом:
to_string(х) // форматирует переменную х из стринга в строку
stoi(x); // форматирует пременную из стринга в число  
если не хочешь что бы после вызода из функции переменная уничтожилась выдели под нее динамическую память с помощью new
s.substr(1, s.size() -2); // 

// Массивы разных типов данных (int, string, char)
   int intArray[] = { 1, 2, 3, 4, 5 };
   string strArray[] = { "hello", "world", "!" };
   string* Fun_name = new string[4]{"Plus", "Minus", "Divide", "Multiply"};
   char charArray[] = { 'a', 'b', 'c' };
   int *intPtr = intArray;
// Время

# include <ctime>
time(NULL) // получаем значение в секундах от 1 января 1970 года(в основном используеться для того что бы получать разное рандомное значение)

// рандом

rand(); //рандомное значение которое не меняеться
srand(); // аздает начальную точку рандома, тоесть рандом не будет ниже указаного в скобках значения. ЕЕ НЕ НАДО ВЫЗЫВАТЬ КАЖДЫЙ РАЗ ПРИ ИСПОЛЬЗОВАНИЯ РАНДОМА, ДОСТАТОЧНО ОДИН РАЗ
rand()% число; // генерирует числа в в диапазоне от 0 до числа которое мы указали
rand()% первое число + второе число ; // генерирует числа в в диапазоне от второго числа до первого числа которое мы указали